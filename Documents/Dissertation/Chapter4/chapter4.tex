\chapter{Testing}

%Detailed descriptions of every test case are definitely not what is required here. What is important is to show that you adopted a sensible strategy that was, in principle, capable of testing the system adequately even if you did not have the time to test the system fully.

%Have you tested your system on \textquoteleft real users\textquoteright ? For example, if your system is supposed to solve a problem for a business, then it would be appropriate to present your approach to involve the users in the testing process and to record the results that you obtained. Depending on the level of detail, it is likely that you would put any detailed results in an appendix.

%The following sections indicate some areas you might include. Other sections may be more appropriate to your project. 

\section{Overall Approach to Testing}
This project has been developed using Test Driven Development (TDD), which means that there is at least one test associated with every method implemented in the system. Instead of collecting every test in one single test-class, they have been split into separate test-classes for each class being tested. A top-level test-class has also been created to make it easier to make sure that every part of the system works as it should, not just isolated classes and methods.

As soon as the map was implemented, it became possible to visually analyse the routes planned by the system to make sure that they follow the expected path. The map also made it possible to compare the routes planned by this system to the routes planned by other route-planners like GraphHopper, Mapzen (both at:\cite{OSM}) and Google Maps\cite{GoogleMaps}. These comparisons showed that PRMs usually have to follow much longer routes than other pedestrians, but also that my route-planning system was able to plan routes through areas where other systems cannot -- like through buildings or across open spaces like a piazza.

\section{Automated Testing}
Most of the Junit tests are fully automated, and only require the programmer's attention whenever they fail. Some test like the complexity-analysis tests do require that the user looks over the output however, as the runtime of each algorithm tends to fluctuate somewhat depending on the IDE, available system-resources, etc. There are Java libraries made exclusively for testing the time/space complexities of specific parts of the system, but they were a little tricky to import and implement into the system, so the simple complexity-analysis performed by the system at the moment will have to do. Those libraries made it sound like they provided higher accuracy than standard measurement-methods by eliminating variables like automatic code-optimizations, IDE-quirks, and fluctuating available system-resources, but they also seemed to be aimed at professional systems where minor optimizations down to the millisecond or nanosecond could have a massive impact on the runtime of the system.

A final automated test is the top-level test-class which runs every other test-class in order, working with the same data as the test-classes before it used and possible modified. This top-level test class is useful because it lets us test the system as a whole, rather than as many separate modules.

\section{Integration Testing}
The top-level test-class made to test every other test-class in the system acts as a sort of \textquotedblleft Big Bang\textquotedblright~Integration test, where most of the system's modules are coupled together to form a complete system. There is also a special test-class made for the Main-class, where the entire system is run, and the programmer has to look at the routes created in order to spot any issues. This test-class does not interact with any other test-class, so if something fails, then the other top-level test-class has to be run in order to find which class and/or method the issue is located in.

The system has also been tested manually by placing the start- and goal-positions at different coordinates in an attempt to break the system, and force a crash.

Another integration test has been performed with a custom graph created specifically for this project, where the optimality and completeness of every search-algorithm can be tested, as well as ensure that all routes are accessible; See Figures \ref{fig:customInaccessible}, \ref{fig:customLongest}, and \ref{fig:customShortest} for illustrations of what this looks like. The custom graph also contains a few Nodes meant to act as loops and dead ends, but because these were hard to include in the illustrations without making everything look really messy and hard to follow, the paths to them have not been included.

\begin{figure}
	\centering
	\caption[Inaccessible path in the custom graph]{Inaccessible path in the custom graph. This route passes through a Way with the tag: \textit{highway=steps}, and is therefore inaccessible. It is the shortest path in the custom graph, but should never be expanded by any algorithm.}
	\label{fig:customInaccessible}
	\frame{\includegraphics[keepaspectratio, width=\columnwidth]{Images/Custom_graph-Inaccessible}}
\end{figure}

\begin{figure}
	\centering
	\caption[Longest path in the custom graph]{The longest path in the custom graph. This route is the longest with respect to distance, but passes through fewer Nodes than Figure \ref{fig:customShortest}. Uninformed search-algorithms like BFS and DFS, and greedy algorithms like GBFS are likely to follow this path.}
	\label{fig:customLongest}
	\frame{\includegraphics[keepaspectratio, width=\columnwidth]{Images/Custom_graph-Longest}}
\end{figure}

\begin{figure}
	\centering
	\caption[Optimal path in the custom graph]{The optimal path in the custom graph. This route is the shortest with respect to distance, but passes through more Nodes than Figure \ref{fig:customLongest}. Informed search-algorithms like A* should always pass through here. Algorithms that follow this path can be considered \textit{optimal}}
	\label{fig:customShortest}
	\frame{\includegraphics[keepaspectratio, width=\columnwidth]{Images/Custom_graph-Shortest}}
\end{figure}


\section{User Testing}
The system has unfortunately not been tested in a real environment, so any routes planned by the system has just been assumed to be accessible for PRMs. There are a few errors in the OSM data used for route-planning (See Figure \ref{fig:badDataBadPath}), where things like stairs that exist in reality are not marked in the dataset (for example on the path between the Llandinam building and Physical Sciences Building), but routes planned through these areas are not the fault of the system, but rather the fault of missing data.

As already stated: Routes passing through buildings cannot be guaranteed to be accessible on the inside of the building, but every entry- and exit-point is guaranteed to be accessible. This is because the interiors of buildings are rarely mapped in the OSM-database -- evident by the lack of interior mapping inside buildings on the Penglais campus of Aberystwyth University -- so there was no reason to develop this functionality in the system; it could be a very useful addition to further improve the functionality of the system however.